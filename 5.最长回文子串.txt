//中心扩张法 range结构体避免L，R判定
class Solution {
public:
    struct range
   {
      int left;
      int right;
      int len;
   };
   range expandAroundCenter(const string &s,int left,int right)
    {
      range res;
      int n=s.size();
      int L=left,R=right;
      while(L>=0&&R<=n&&s[L]==s[R])
      {
            L--;
            R++;
      }
      res.left=L+1;
      res.right=R-1;
      res.len=R-L-1;
      return res;
    }
    string longestPalindrome(string s) {
        int n=s.size();
        if(n<1)
          return "";
        range res;
        res.len=0;
        for(int i=0;i<n;i++)
        {
            range oddRange=expandAroundCenter(s,i,i);
            range evenRange=expandAroundCenter(s,i,i+1);

            if(oddRange.len>=evenRange.len)
            {
                if(res.len<oddRange.len)
                  res=oddRange;
            }
            else
            {
                if(res.len<evenRange.len)
                  res=evenRange;
            }
        }
        return s.substr(res.left,res.len);
    }
};
//马拉车算法 Manacher算法
class Solution {
public:
    string longestPalindrome(string s) {
        int n=s.size();
        if(n<1)
          return "";

        string s1;
        for(int i=0;i<n;i++)
        {
            s1+='#';
            s1+=s[i];
        }
        s1+='#';

        n=s1.size();
        int MaxRight=0;//当前所有回文子串的最右边界
        int pos=0;//MaxRight对应的回文串的中心
        int MaxRL=0;//最大回文串的回文半径
        int MaxPos=0;//MaxRL对应的回文串的中心
        int RL[n]={0};//回文半径数组

        for(int i=0;i<n;i++)
        {
            if(i<MaxRight)
            {//i在MaxRight的左边
                RL[i]=min(RL[2*pos-i],MaxRight-i);
            }
            else
            {//当i在MaxRight的右边
                RL[i]=1;
            }

            //扩展RL[i]
            while(i-RL[i]>=0&&i+RL[i]<n&&s1[i-RL[i]]==s1[i+RL[i]])
              RL[i]++;
            
            //更新MaxRight及pos
            if(RL[i]+i>MaxRight)
            {
                MaxRight=RL[i]+i;
                pos=i;
            }

            //更新MaxRL及MaxPos
            if(MaxRL<=RL[i])
            {
                MaxRL=RL[i];
                MaxPos=i;
            }
        }

        return s.substr((MaxPos-MaxRL+1)/2,MaxRL-1);
    }
};

//动态规划
class Solution {
public:
    string longestPalindrome(string s) {
        int n=s.size();
        if(n<2)
          return s;
        
        bool dp[n][n];
        int start=0;
        int end=0;
        
        for(int i=0;i<n;i++)
        {
            dp[i][i]=true;
        }

        for(int r=1;r<n;r++)
          for(int l=0;l<r;l++)
            if(s[r]==s[l]&&(r-l==1||dp[l+1][r-1]))//动态转移方程
            {
                dp[l][r]=true;
                if(r-l>end-start)
                {
                    end=r;
                    start=l;
                }
                continue;
            }
            else
              dp[l][r]=false;
            
        return s.substr(start,end-start+1);
    }
};
