//顺序查找
   复杂度分析：　
　　查找成功时的平均查找长度为：（假设每个数据元素的概率相等） 
       ASL = 1/n(1+2+3+…+n) = (n+1)/2 ;
　　当查找不成功时，需要n+1次比较，时间复杂度为O(n);
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        if(nums.empty())
            return 0;
        for(int i=0;i<nums.size();i++)
        {
            if(nums[i]>=target)
                return i;
        }
        return nums.size();
    }
};

//二分查找
   复杂度分析：最坏情况下，关键词比较次数为log2(n+1)，且期望时间复杂度为O(log2n)；
   折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半
查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序
会带来不小的工作量，那就不建议使用。
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        if(nums.empty())
            return 0;
        int high=nums.size()-1;
        int low=0;
        int mid;
        while(low<high)
        {
            mid=(low+high)/2;
            if(nums[mid]==target)
                return mid;
            if(nums[mid]>target)
                high=mid-1;
            if(nums[mid]<target)
                low=mid+1;
        }
        if(nums[low]<target)
            return low+1;
        return low;
    }
};

//递归二分
class Solution {
public:
    int BinarySearch(vector<int>& nums,int target,int high,int low)
    {
        if(low==high)
            return low;
        int mid=low+(high-low)/2;
        if(nums[mid]<target)
        {
            low=mid+1;
            if(low<high)
                return BinarySearch(nums,target,high,low);
        }
        if(nums[mid]>target)
        {
            high=mid-1;
            if(low<mid-1)
                return BinarySearch(nums,target,high,low);
        }
        if(nums[mid]==target)
            return mid;
        return low;
    }
    int searchInsert(vector<int>& nums, int target) {
        if(nums.empty())
            return 0;
        int low=BinarySearch(nums,target,nums.size()-1,0);
        if(nums[low]==target)
            return low;
        if(nums[low]<target)
            return low+1;
        return low;
    }
};

//插值查找
对二分法的优化 使得中值求解更有自适应性 在表长较大且分布均匀的有序表具有较好的表现
基于题目本身需要返回插入的位置 所以加了判断条件 单纯的插值查找将mid的求解公式替换即可
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int low=0;
        int high=nums.size()-1;
        int mid;
        while(low<high)
        {
            mid=(target-nums[low])/(nums[high]-nums[low])*(high-low)+low;
            if(nums[mid]==target)
                return mid;
            int a=mid+1;
            if(mid<nums.size()-1&&nums[mid]<target&&nums[a]>target)
                return a;
            if(nums[mid]<target)
            {
                if(mid+1<nums.size()-1)
                    low=mid+1;
                else
                    low=high;
            }
            if(nums[mid]>target)
            {
                if(mid-1>=0)
                    high=mid-1;
                else
                    high=low;
            }
        }
        if(nums[low]<target)
            return low+1;
        return low;
    }
};